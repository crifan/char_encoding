<?xml version='1.0' encoding="utf-8"?>

<!DOCTYPE chapter
[

<!ENTITY % crl_ent PUBLIC "crl.ent" 'http://www.crifan.com/files/res/docbook/entity/crl.ent'>
%crl_ent;

]>

<chapter 
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xl="http://www.w3.org/1999/xlink"
    
    xml:id="ch02_enc_type">

<title>字符编码标准</title>

    <xi:include href="ch02s1_ascii.xml" />

    <sect1 xml:id="enc_eascii_iso8859"><title>支持多种衍生拉丁字母的字符编码：EASCII和ISO 8859</title>
        <para>计算机出现之后，从美国发展到欧洲，而由于欧洲很多国家中所用到的字符中，除了基本的美国也用的那些拉丁字母之外，还有很多衍生的拉丁字母，而且是不同的国家用到的衍生字符都不太相同，所以欧洲人也遇到类似的问题，即如何将自己国家的那些字符，在计算机上显示出来，这就需要设计一个合理的字符编码，把所有这些字符都囊括其中。</para>
        <para>即设计一个新编码标准，即兼容旧的ASCII的编码，又支持欧洲多个国家的那些衍生拉丁字母。</para>
        <para>这样的标准有两个，一个是EASCII编码标准，一个是国际标准ISO 8859字符编码标准。</para>
        
        <sect2 xml:id="enc_eascii"><title>EASCII</title>
            <para>将ASCII中的第八位也用上，那么就是8位的字符编码了，然后将EASCII中0xA0-0xFF这部分比ASCII码扩充出来的编码，用来表示表格符号、计算符号、希腊字母和特殊的拉丁符号等，这样就可以实现支持那么多欧洲的衍生拉丁字母了，也就是这个EASCII字符编码了。但是EASCII虽然解决了这些西欧语言的字符显示问题，但是对于其他语言显示，比如中文等，还是无法处理显示。</para>
            <para>目前，很少使用EASCII，常用的是下面要介绍的<xref linkend="enc_iso8859" />编码标准。</para>
        </sect2>
        
        <sect2 xml:id="enc_iso8859"><title>ISO 8859</title>
            <sect3 xml:id="iso_iec_8859_background"><title>ISO/IEC 8859出现的背景</title>
                <para>前面已经提到了，正是因为ASCII等字符编码中，没有包括欧洲很多国家所用到的一些扩展的拉丁字母，比如一些重音字母，带音标的等等，所以，才设计出新的这个ISO/IEC 8859来支持这些字符。</para>
                <para>最终设计出来的ISO/IEC 8859的字符集，支持很多欧洲的语言，包括丹麦语、荷兰语、德语、意大利语、拉丁语、挪威语、葡萄牙语、西班牙语，瑞典语等。</para>
            </sect3>
            
            <sect3 xml:id="iso_iec_8859_rule"><title>ISO/IEC 8859的编码规则</title>
                <para>我们已经知道了，ASCII是7位的单字节编码，其中0x20-0x7E的可见字符。</para>
                <para>而ISO/IEC 8859，是在ASCII中的普通的可见字符(0x20-0x7E)的基础上，利用了ASCII的7位编码所没有用到的第8位，这样就编码范围就从原先ASCII的0x00-0x7F多扩展出了0x80-0xFF，其中的0xA0-0xFF部分，被ISO/IEC 8859编码所用到。</para>
                <para>有别于ASCII的单个独立的编码规则，ISO/IEC 8859是一组编码规则的总称，其下包含了共15个字符集，即ISO/IEC 8859-n,其中n=1,...,11,13,...,16。</para>
                <para>关于这15种字符集是如何分类的，可以参考：<xref linkend="tbl.isoiec8859_15_charset" /></para>
                <para>这15个字符集，每一个字符集，编码取值都是0xA0-0xFF，但是对于同一个值，不同字符集所对应的字符，都不太一样。</para>
                <para>此处截取那15个字符集的其中一部分，以便更加直观的了解不同字符集的区别： </para>
                <figure xml:id="fg.isoiec8859_15_diff"><title>ISO/IEC 8859的15个字符集的部分比较</title>
                    <mediaobject>
                        <imageobject role="html"><imagedata fileref="images/isoiec8859_15_diff.png" scalefit="0" width="100%" /></imageobject>
                        <imageobject role="fo">  <imagedata fileref="images/isoiec8859_15_diff.png" scalefit="1" width="100%" /></imageobject>
                    </mediaobject>
                </figure>
                <para>完整的字符表，请参见<xref linkend="tbl.isoiec8859_15_charset" /></para>
                <note xml:id="nt.ascii_sometime_is_8859_1"><title>ASCII编码有时候也会写成ISO/IEC 8859-1编码</title>
                    <para>另外，需要注意的是，对于原先的美国的英文字母，即普通的英语，其虽然没有重音，音标等字母，但是由于其本身也还是包含在ASCII中，而ISO/IEC 8859-1包括了ASCII,所以，很多时候，对于英文字母来说，也仍会标明为ISO/IEC 8859-1编码。</para>
                </note>
            </sect3>
            
            <sect3 xml:id="iso_iec_8859"><title>ISO/IEC 8859的特点</title>
                <para>对于ISO/IEC 8859所包含的全部字符，我们可以看到，对于基本的拉丁字母，那都是和ASCII一样的，因为其就是借用了ASCII中的0x20-0x7F这段的编码，对应的是那些常见的可显示的字符，而对于0xA0-0xFF这段空间，则是对于同一个值，不同的字符集中，对应着不同的符号。</para>
                <para>对于ISO/IEC 8859的编码方式是设计了多个字符集，我们不难看出，其之所以这么编码，而不是像ASCII中每个编码值，都对应唯一的一个字符，那是因为，欧洲的全部所用的字符数很多，如果是对于全部的欧洲用的字符都用一个对应的值来表示，那么这剩下的0xA0-0xFF，甚至是0x80-0xFF，也都不够用的，因为0x80-0xFF128个值，当然不够表示欧洲那几百上千的不同国家的不同字符。</para>
                <para>所以，才会去设计出这么15个字符集，然后对于同一个值，你用了ISO/IEC 8859-n,就表示对应的字符集中的那个特定的字符。</para>
                <para>而上述做法的好处是，可以避免去用多个字节，比如两个字节（8×2=16位，可以表示最多2^16=65536个字符）去表示一个单独的字符，即节省了存放数据的空间。</para>
                <para>但是缺点是，比如你写一篇文章，中间出现了多个不同语系的不同的字符，那么此文章如果用ISO/IEC 8859来编码的话，那么就无法单独存成某一种对应的字符集，即包含多个欧洲国家不同语系的特殊字符的数据，无法用ISO/IEC 8859的某一个单独的字符集来表示出来，即无法在同一个文章中支持显示不同语系的不同的字符。</para>
                <para>当然，相对于亚洲字符，即中文，日文，韩文等字符来说，另外一个如果算的上是缺点的话，那就是没有把咱亚洲字符考虑进去。</para>
                <para>正因此，字符编码，才会继续演化出更加通用的，包含了世界上所有的字符的字符编码标准：Unicode。</para>
                <para>关于Unicode的详细解释请去看：<xref linkend="enc_unicode" /></para>
                <para>此处先来说说，其他几个和ISO/IEC 8859相关的内容。</para>
            </sect3>
            
            <sect3 xml:id="iso_iec_6429"><title>ISO/IEC 6429</title>
                <para>可以看到，对应的ASCII编码取值范围是0x0-0x7F，而ISO/IEC 8859虽然是8位的单字节的编码，但是只是除了ASCII的0x20-0x7E之外，只是指定了0xA0-0xFF，而中间还有一段的值，即0x80-0x9F，却没有定义。</para>
                <para>对此部分，是对应的ISO/IEC 6429编码标准所定义的，此标准还定义了0x0-0x1F，即ASCII中的控制字符。</para>
                <para>即，ISO/IEC 6429是专门定义对应的控制字符的，其中，0x0-0x1F部分称为C0控制（C0 control ）字符，0x80-0x9F部分称为C1控制（C1 control）字符。</para>
                <para>对应的C0 control部分，和ASCII编码重复定义了，但是两者含义都是一样的，所以编码规则并不冲突。</para>
                <para>可以算是，在控制字符领域，ISO/IEC 6429在ASCII的C0 control的基础上，对于由ASCII的7位所扩展出的8位编码中的0x80-0x9F这部分，也做出了对应的定义。</para>
                <para>简言之：</para>
                <para><emphasis>ISO/IEC 6429 </emphasis></para>
                <para><emphasis>= 0x0-0x1F + 0x80-0x9F</emphasis></para>
                <para><emphasis>=7位编码ASCII中的0x0-0x1F   + 扩展8位编码中的0x80-0x9F</emphasis></para>
                <para><emphasis>=C0 control + C1 control</emphasis></para>
            </sect3>

            <sect3 xml:id="iso8859_vs_iso_8859"><title>ISO 8859和ISO-8859的区别和联系</title>
                <para>ISO 8859和ISO-8859，不是同一个东西。</para>
                <para>注意，后者是ISO和8859中间带了一个小横短线的。</para>
                <para>前者，ISO 8859是ISO/IEC 8859标准集合的简称，对应包含了 ISO/IEC 8859-n,其中n为除去2之外的1到16，这共15种字符集合。</para>
                <para>ISO-8859，是ISO-8859-n的简称，是IANA根据ISO/IEC 8859-n的标准，加上对应的前面提到的普通的ASCII字符，和ISO/IEC 6429所定义的的控制字符，所制定的标准。</para>
                <para>其中，由于ASCII中也包含了0x00-0x1F的控制字符，所以和ISO/IEC 6429中的C0控制字符重复了，但是两者定义都是一样的，所以从字符编码上来说，不会产生任何冲突。</para>
                <para>因此，ISO-8859-n所以可以表示：</para>
                <para><emphasis>ISO-8859</emphasis></para>
                <para><emphasis>= ISO-8859-n的简称</emphasis></para>
                <para><emphasis>= ISO 8859-n + ASCII + ISO/IEC 6429</emphasis></para>
                <para>其中，n=1,...,11,13,...,16，共15种编码集合。</para>
                <para>对应的，ISO 8859-1和ISO-8859-1两者当前也是不一样的，其区别也是：</para>
                <para></para>
                <para><emphasis>ISO-8859-1</emphasis></para>
                <para><emphasis>= ISO 8859-1     + ASCII + ISO/IEC 6429</emphasis></para>
                <para><emphasis>= ISO/IEC 8859-1 + ASCII + ISO/IEC 6429</emphasis></para>
                
                <sect4 xml:id="orig_iso8859_1_vs_normal_iso8859_1"><title>原先的ISO 8859-1和我们常说的ISO 8859-1</title>
                    <para>原先的ISO 8859-1即ISO/IEC 8859-1，其编码前面已经介绍过了，此处只是给出对应的字符表：</para>
                    <figure xml:id="fg.isoiec8859_1_charset"><title>ISO/IEC 8859-1字符集表</title>
                        <mediaobject>
                            <imageobject role="html"><imagedata fileref="images/isoiec8859_1_charset.png" scalefit="0" width="100%" /></imageobject>
                            <imageobject role="fo">  <imagedata fileref="images/isoiec8859_1_charset.png" scalefit="1" width="100%" /></imageobject>
                        </mediaobject>
                    </figure>
                    <para>其中绿色的部分，就是原先ISO 8859-1中未定义的部分。而这部分，之前已经解释了，是在另外的一个标准ISO/IEC 6429中定义的。</para>
                    <para>此处，需要注意的是，目前大家最常见的，提到最多的ISO 8859-1，实际多数都是指的是ISO-8859-1，即，是那个，既整合了0x20-0x1F这部分的普通的可以显示的ASCII字母（基本的拉丁字母），又包含了对应的控制字符（ C0 control和C1 control），同时也包含了欧洲多数国家所用到那些字符（扩展的拉丁字母，即ISO/IEC 8859-1中所定义的那些字符）。</para>
                    <para>总结起来就是：</para>
                    <para><emphasis>常说的ISO 8859-1</emphasis></para>
                    <para><emphasis>= 实际上是ISO-8859-1</emphasis></para>
                    <para><emphasis>= ASCII + ISO/IEC 6429 + ISO 8859-1         </emphasis></para>
                    <para><emphasis>= ASCII + ISO/IEC 6429 + ISO/IEC 8859-1</emphasis></para>
                    <para><emphasis>= (0x20-0x1F) + (0x0-0x1F + 0x80-0x9F) + (0xA0-0xFF)</emphasis></para>
                    <para><emphasis>= ASCII中的可见字符 + C0和C1的控制字符 + 欧洲多国所用的扩展的拉丁字符</emphasis></para>
                </sect4>
            </sect3>
        </sect2>
    </sect1>
    
    <sect1 xml:id="single_byte_enc"><title>各种单字节编码标准的关系</title>
        <para>不论是ASCII的7位的编码，还是后期演化出来的ISO/IEC 8859的8位的编码，都还是用单个字节就可以表示一个字符，叫做单字节编码。</para>
        <para>各种单字节编码之间的关系，可以用下面图表来解释：</para>
        <table xml:id="tbl.single_byte_enc_relation" align="center"><title>各种单字节编码标准之间的关系</title>
            <tgroup cols="7" >
                <colspec colnum="1" colname="col1" colwidth="1*" />
                <colspec colnum="2" colname="col2" colwidth="2*" />
                <colspec colnum="3" colname="col3" colwidth="1*" />
                <colspec colnum="4" colname="col4" colwidth="1*" />
                <colspec colnum="5" colname="col5" colwidth="1*" />
                <colspec colnum="6" colname="col6" colwidth="1*" />
                <colspec colnum="7" colname="col7" colwidth="1*" />
                <spanspec spanname="15rows" morerows="14" valign="middle"/>

                
                <thead>
                    <row><entry namest="col1" nameend="col2">单字节编码</entry><entry namest="col3" nameend="col7" >单个字节=8位=2<superscript>8</superscript>=256个字符</entry></row>
                    <row><entry morerows="1" valign="middle" >编码标准</entry><entry morerows="1" valign="middle" >注释</entry><entry namest="col3" nameend="col5">用到了前7位=2<superscript>7</superscript>=128个字符</entry><entry namest="col6" nameend="col7">用到了第8位</entry></row>
                    <row><entry colname="col3">0x0-0x1F</entry><entry>0x20<co id="co.20_space" linkends="co.note.20_space"/>-0x7E</entry><entry>0x7F</entry><entry>0x80-0x9F</entry><entry>0xA0-0xFF</entry></row>
                </thead>
                
                <tbody>
                    <row><entry>ASCII</entry><entry>=ISO/IEC 646</entry><entry>&bgcolor_orange;yes</entry><entry>&bgcolor_orange;yes</entry><entry>&bgcolor_orange;yes</entry><entry></entry><entry></entry></row>
                    <row><entry>ISO/IEC 6429</entry><entry>=C0 control + C1 control</entry><entry>&bgcolor_orange;yes</entry><entry></entry><entry></entry><entry>&bgcolor_orange;yes</entry><entry></entry></row>
                    <row><entry morerows="14" valign="middle">ISO 8859</entry>
                        <entry morerows="14" valign="middle">
                            <simplelist type="vert">
                                <member>=ISO/IEC 8859-n</member>
                                <member>=</member>
                                <member>ISO/IEC 8859-1</member>
                                <member>......</member>
                                <member>ISO/IEC 8859-11</member>
                                <member>ISO/IEC 8859-13</member>
                                <member>......</member>
                                <member>ISO/IEC 8859-16</member>
                            </simplelist>
                        </entry>
                        <entry morerows="14" valign="middle"></entry><entry morerows="14" valign="middle">&bgcolor_orange;yes</entry><entry morerows="14" valign="middle"></entry><entry morerows="14" valign="middle"></entry><entry>&bgcolor_orange;yes</entry>
                    </row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    
                    <row><entry morerows="14" valign="middle">ISO-8859</entry>
                        <entry morerows="14" valign="middle">
                            <simplelist type="vert">
                                <member>=ISO-8859-n</member>
                                <member>=</member>
                                <member>ISO-8859-1</member>
                                <member>......</member>
                                <member>ISO-8859-11</member>
                                <member>ISO-8859-13</member>
                                <member>......</member>
                                <member>ISO-8859-16</member>
                            </simplelist>
                        </entry>
                        <entry morerows="14" valign="middle">&bgcolor_orange;yes</entry>
                        <entry morerows="14" valign="middle">&bgcolor_orange;yes</entry>
                        <entry morerows="14" valign="middle">&bgcolor_orange;yes</entry>
                        <entry morerows="14" valign="middle">&bgcolor_orange;yes</entry>
                        <entry>&bgcolor_orange;yes</entry>
                    </row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                    <row><entry colname="col7">&bgcolor_orange;yes</entry></row>
                </tbody>
            </tgroup>
        </table>
        <calloutlist>
            <callout id="co.note.20_space" arearefs="co.20_space" >
                <para>0x20是空格Space，常缩写为SP。</para>
                <para>此空格字符，严格意义上说，属于不可显示字符，因为显示或打印出来，也看不见</para>
            </callout>
        </calloutlist>
    </sect1>
    
    <sect1 xml:id="enc_unicode"><title>支持世界上几乎所有字符的字符编码：Unicode</title>
        <para>好了，介绍完了ISO/IEC 8859的种种，这下可以开始介绍Unicode了。</para>
        <para>前面已经提到了，由于随着计算机的发展，自然会发展到亚洲各国和其他一些地方，然后这些国家也遇到同样问题，即如何把自己的国家的字符，显示到对应的屏幕上。</para>
        
        <sect2 xml:id="unicode_iso10646_relation"><title>Unicode和ISO 10646的关系</title>
            <para>Unicode这个词的中文翻译，有译为万国码，单一码，标准万国码，但是最常见的翻译还是统一码。</para>
            
            <sect3 xml:id="iso19646_ucs"><title>ISO 10646=UCS</title>
                <para>国际标准组织ISO，定义了对应的编码标准ISO/IEC 10646，简称为ISO 10646，此标准所定义的字符集，称作为通用字符集（Universal Character Set，UCS）。</para>
                <para>并不是所有的系统都需要支持像組合字符这样的的先进机制。</para>
                <para>因此ISO 10646指定了如下三种实现级别:</para>
                <orderedlist>
                    <listitem>级别1：不支持组合字符和諺文字母字符。</listitem>
                    <listitem>级别2：类似于级别1，但在某些文字中，允许一列固定的组合字符，因为如果没有最起码的几个组合字符，UCS就不能完整地表达这些语言。</listitem>
                    <listitem>级别3：支持所有的通用字符集字符，如，可以在任意一个字符上加上一个箭头或一个鼻音化符號</listitem>
                </orderedlist>
                <para>即，对于多数的实际使用中，并不一样要求你实现包括世界上所有的字符，那就不一定非的要实现对应的第三级别，很多时候只需要实现第一级别就足够涵盖平常所用到的大部分的字符了。</para>
                <para>我们平时会看到UCS-2，UCS-4，就是对应的ISO 10646标准中所定义的，对应的用2个字节或4个字节去表示同一个字符。</para>
            </sect3>
            
            <sect3 xml:id="unicode_iso10646_similarity"><title>Unicode 和ISO 10646的联系</title>
                <para>历史上存在两个独立的尝试创立单一字符集的组织，即国际标准化组织（ISO）和多语言软件制造商组成的统一码联盟。</para>
                <para>前者开发的 ISO/IEC 10646 项目，后者开发的Unicode项目。</para>
                <para>因此最初制定了不同的标准。</para>
                <para>1991年前后，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode 2.0开始，Unicode采用了与ISO 10646-1相同的字库和字码；ISO也承诺，ISO 10646将不会超出U+10FFFF的UCS-4编码赋值，以使得两者保持一致。</para>
                <para>两个项目仍都存在，并独立地公布各自的标准，但统一码联盟和ISO/IEC JTC1/SC2都同意保持两者标准的码表兼容，并紧密配合以保证之后的扩展也一致。</para>
                <para>其各自的标准之间的对应关系如下：</para>
                <table xml:id="tbl.10640_vs_unicode"><title>ISO/IEC 10646与Unicode的版本对应关系</title>
                    <tgroup cols="2">
                        <colspec colnum="1" colname="col1" colwidth="3*" />
                        <colspec colnum="2" colname="col2" colwidth="1*" />
                        
                        <thead>
                            <row><entry>ISO/IEC 10646版本</entry><entry>Unicode版本</entry></row>
                        </thead>
                        
                        <tbody>
                            <row><entry>ISO/IEC 10646-1:1993</entry><entry>Unicode 1.1</entry></row>
                            <row><entry>ISO/IEC 10646-1:2000</entry><entry>Unicode 3.0</entry></row>
                            <row><entry>ISO/IEC 10646-2:2001</entry><entry>Unicode 3.2</entry></row>
                            <row><entry>ISO/IEC 10646:2003</entry><entry>Unicode 4.0</entry></row>
                            <row><entry>ISO/IEC 10646:2003 plus Amendment 1</entry><entry>Unicode 4.1</entry></row>
                            <row><entry>ISO/IEC 10646:2003 plus Amendment 1, Amendment 2, and part of Amendment 3</entry><entry>Unicode 5.0</entry></row>
                            <row><entry>ISO/IEC 10646:2003 plus Amendments 1 to 4</entry><entry>Unicode 5.1</entry></row>
                            <row><entry>ISO/IEC 10646:2003 plus Amendments 1 to 6</entry><entry>Unicode 5.2</entry></row>
                            <row><entry>ISO/IEC 10646:2011</entry><entry>Unicode 6.0</entry></row>
                        </tbody>
                    </tgroup>
                </table>
            </sect3>

            <sect3 xml:id="unicode_vs_iso10646"><title>Unicode和ISO 10646的区别</title>
                <para>统一码联盟公布的Unicode标准包含了ISO/IEC 10646-1实现级别3的基本多文种平面BMP。在两个标准里，所有的字符都在相同的位置并且有相同的名字。</para>
                <para>ISO/IEC 10646标准，就像ISO/IEC 8859标准一样，只不过是一个简单的字符集表。它定义了一些编码的别名，指定了一些与标准有关的术语，并包括了规范说明，指定了怎样使用UCS连接其他ISO标准的实现，比如ISO/IEC 6429和ISO/IEC 2022。还有一些与ISO紧密相关的，比如ISO/IEC 14651是关于UCS字符串排序的。</para>
                <para>Unicode标准，额外定义了许多与字符有关的语义符号学。Unicode详细说明了绘制某些语言（如阿拉伯语）表达形式的算法，处理双向文字（比如拉丁文和希伯来文的混合文字）的算法，排序与字符串比较所需的算法，等等。</para>
                <para>所以，可以理解为，ISO 10646中定义了编码规则，定义了哪些值对应了哪些字符，而Unicode不仅定义了这些编码规则，还定义了其他一些关于文字处理的细节算法等内容。</para>
                <para>即：</para>
                <para><emphasis>Unicode</emphasis></para>
                <para><emphasis>= ISO 10646的编码规则 + 某些语言的细节处理算法</emphasis></para>
                <para>对于一般人来说，Unicode 和 ISO 10646，虽然两者有些细节的区别，但是我们多数不用去关系这点细节内容，而对于字符编码规则方面，此处可以简单的理解为：</para>
                <para><emphasis>Unicode</emphasis></para>
                <para><emphasis>= ISO 10646编码标准</emphasis></para>
                <para><emphasis>= 标准所制定的UCS字符集</emphasis></para>
            </sect3>
        </sect2>
        
        <sect2 xml:id="unicode_rule"><title>Unicode编码规则</title>
            <para>为了将世界上几乎所有的字符都涵盖了，那么就要了解世界上，有哪些字符。</para>
            <para>除了之前ASCII的拉丁字母，ISO 8859所包含的欧洲多国用的字符之外，亚洲一些国家，包括中文，日文，韩文等，尤其是中文，包含的字符数，大概有几万个。</para>
            <para>因此，Unicode的编码就要设计的把这么多的字符都包含在内。</para>
            <para>Unicode的编码方式与上面提到的ISO 10646的UCS概念相对应，目前实际应用的Unicode版本对应于UCS-2，即2字节的UCS字符集，使用16位的编码空间。每个字符占用2个字节，这样理论上一共最多可以表示2^16=65536个字符。基本满足各种语言的使用。实际上目前版本的Unicode尚未填充满这16位编码，保留了大量空间作为特殊使用或将来扩展。</para>
            <para>上述16位Unicode字符构成基本多文种平面（Basic Multilingual Plane，简称BMP）。最新（但未实际广泛使用）的Unicode版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。</para>
            <para>UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示2^31=2147483648=21亿左右个字符，完全可以涵盖一切语言所用的符号。</para>
            <para>具体的取值范围和所对应的平面空间划分，参见<xref linkend="fg.unicoed_multi_plan" /></para>
            <figure xml:id="fg.unicoed_multi_plan"><title>Unicode中的各种平面划分</title>
                <mediaobject>
                    <imageobject role="html"><imagedata fileref="images/unicoed_multi_plan.png" scalefit="0" width="100%" /></imageobject>
                    <imageobject role="fo">  <imagedata fileref="images/unicoed_multi_plan.png" scalefit="1" width="100%" /></imageobject>
                </mediaobject>
            </figure>
            <para>Unicode中的0-0xFFF的BMP中的任何一个编码的值，称为码点（Code Point），对应用U+hhhh来表示，其中每个h 代表一个十六进制数位。</para>
            <para>与UCS-2编码完全相同。对应的4字节UCS-4编码后两个字节一致，前两个字节的所有位均为0。</para>
        </sect2>
        
        <sect2 xml:id="unicode_storage_and_exchange"><title>Unicode字符编码所对应的存储和交换标准：UTF-8, UTF-16, UTF-32</title>
            <para>需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</para>
            <para>比如，汉字“严”的Unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</para>
            <para>这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个Unicode中的字符，而不是分别表示三个ASCII的 字符呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</para>
            <para>它们造成的结果是：</para>
            <orderedlist>
                <listitem>出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode</listitem>
                <listitem>Unicode在很长一段时间内无法推广，直到互联网的出现</listitem>
            </orderedlist>
            
            <sect3 xml:id="enc_utf8"><title>UTF-8</title>
                <para>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。</para>
                <para><emphasis>重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</emphasis></para>
                <para>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</para>
                <para>UTF-8的编码规则很简单，只有二条：</para>
                <itemizedlist>
                    <listitem>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的</listitem>
                    <listitem>对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的Unicode码</listitem>
                </itemizedlist>
                <para>下表总结了编码规则，字母x表示可用编码的位。</para>
                <table xml:id="tbl.unicode_utf8_relation"><title>Unicode与UTF-8之间的编码映射关系</title>
                    <tgroup cols="2">
                        <thead>
                            <row><entry>Unicode符号范围(十六进制)</entry><entry>UTF-8编码方式（二进制）</entry></row>
                        </thead>
                        
                        <tbody>
                            <row><entry>0000 0000-0000 007F</entry><entry>0xxxxxxx</entry></row>
                            <row><entry>0000 0080-0000 07FF</entry><entry>110xxxxx 10xxxxxx</entry></row>
                            <row><entry>0000 0800-0000 FFFF</entry><entry>1110xxxx 10xxxxxx 10xxxxxx</entry></row>
                            <row><entry>0001 0000-0010 FFFF</entry><entry>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</entry></row>
                        </tbody>
                    </tgroup>
                </table>
                <para>下面，还是以汉字“严”为例，演示如何实现UTF-8编码。</para>
                <para>已知“严”的Unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</para>
            </sect3>
            
            <sect3 xml:id="unicode_utf8_conversion"><title>Unicode与UTF-8之间的转换</title>
                <para>通过上一节的例子，可以看到“严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。</para>
                <para>在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击"文件"<phrase role="symbol">&rarr;</phrase>"另存为"会跳出一个对话框，在最底部有一个"编码"的下拉条:</para>
                <figure xml:id="fg.notepad_enc"><title>Notepad中的各种编码</title>
                    <mediaobject>
                        <imageobject role="html"><imagedata fileref="images/notepad_enc.png" scalefit="0" width="100%" /></imageobject>
                        <imageobject role="fo">  <imagedata fileref="images/notepad_enc.png" scalefit="1" width="100%" /></imageobject>
                    </mediaobject>
                </figure>
                <para>里面有四个选项：ANSI，Unicode，Unicode big Endian 和 UTF-8:</para>
                <itemizedlist>
                    <listitem>ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。</listitem>
                    <listitem>Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的Little Endian格式</listitem>
                    <listitem>Unicode Big Endian编码与上一个选项相对应
                        <para>关于Little Endian和Big Endian，可以参考<link xl:href="http://www.crifan.com/big_endian_big_endian_and_small_end_little_endian_detailed/">大端(Big Endian)与小端(Little Endian)详解</link></para>
                    </listitem>
                    <listitem>UTF-8编码，也就是上一节谈到的编码方法</listitem>
                </itemizedlist>
                <para>选择完”编码方式“后，点击”保存“按钮，文件的编码方式就立刻转换好了。</para>
                <para>下面，举一个实例:</para>
                <para>打开”记事本“程序Notepad.exe，新建一个文本文件，内容就是一个”严“字，依次采用ANSI，Unicode，Unicode big Endian 和 UTF-8编码方式保存。</para>
                <para>然后，用文本编辑软件UltraEdit的”十六进制功能“，观察该文件的内部编码方式。</para>
                <itemizedlist>
                    <listitem><emphasis>ANSI</emphasis>
                        <para>文件的编码就是两个字节“D1 CF”，这正是“严”的GB2312编码，这也暗示GB2312是采用大头方式存储的</para>
                    </listitem>
                    <listitem><emphasis>Unicode</emphasis>
                        <para>编码是四个字节“FF FE 25 4E”，其中“FF FE”表明是小头方式存储，真正的编码是4E25。</para>
                    </listitem>
                    <listitem><emphasis>Unicode big Endian</emphasis>
                        <para>编码是四个字节“FE FF 4E 25”，其中“FE FF”表明是大头方式存储。</para>
                    </listitem>
                    <listitem><emphasis>UTF-8</emphasis>
                        <para>编码是六个字节“EF BB BF E4 B8 A5”，前三个字节“EF BB BF”表示这是UTF-8编码，后三个“E4B8A5”就是“严”的具体编码，它的存储顺序与编码顺序是一致的</para>
                    </listitem>
                </itemizedlist>
                
                <sect4 xml:id="utf8_bom_efbbbf"><title>关于UTF-8的BOM：“EF BB BF”</title>
                    <para>对于UTF-8的BOM（Byte Order Mark），即“EF BB BF”，是对于UTF-8编码，微软自己添加的，由此，会导致和其他很多软件等不兼容。而Unicode标准中，也不推荐此给UTF-8添加“EF BB BF”的BOM。</para>
                    <para>刚去测试了一下，在Window XP中，将中文汉字“严”在记事本中另存为UTF-8之后，用Notepad++去查看其十六进制的值，的确是“EF BB BF E4 B8 A5”，然后手动删除了“EF BB BF”的BOM，保存后，再去用记事本打开，发现没了BOM的UTF-8，记事本也是可以正确显示出“严”字的。所以，结论是：</para>
                    <orderedlist>
                        <listitem>给UTF-8加“EF BB BF”的BOM，是微软自己的做法，即微软发现编码是UTF-8的话，会给文件最开始加上“EF BB BF”</listitem>
                        <listitem>Unicode的官方标准，不推荐这种做法，即不推荐给UTF-8加“EF BB BF”的BOM</listitem>
                        <listitem>所以，其他人写软件处理文字编码的话，最好不要给UTF-8加BOM。当然，如果你非得要兼容微软的做法，那么去解析不同编码的文件的话，针对UTF-8编码，就要考虑这个特殊的的BOM了</listitem>
                    </orderedlist>
                    <para>更多关于BOM的解释，参见<xref linkend="bom" /></para>
                </sect4>
            </sect3>
        </sect2>
    </sect1>

    <sect1 xml:id="code_page"><title>代码页Code Page</title>
        <sect2 xml:id="what_is_code_page"><title>什么是代码页（Code Page）</title>
            <para>Code Page，是字符编码的另一种说法。</para>
            <para>Code Page包含了一个表，表中的值，用于表示针对某种语言所用的字符集。</para>
            <para>更简单点说，就是Code Page中，用一个数字编号，表示了所要采用何种字符编码，去编解码相应的值，用于正确显示出相应的字符。</para>
            <para>Code Page这一概念，源于IBM，后被其他常见广泛采用，包括Microsoft，SAP，Oracle等。</para>
            <para>这些常见，各自定义了一套自己的Code Page，给每一个code page号，指定一个字符编码。</para>
            <para>比如，对于众所周知的UTF-8编码，在IBM的Code Page中编号是1208，在微软中是65001，在SAP中是4110。</para>
            <para>接下来，主要介绍大家最常见的Windows的Code Page</para>
        </sect2>
        
        <sect2 xml:id="code_page_in_windows"><title>Windows中的Code Page</title>
            <para>如前所述，Windows中也有自己的一套Code Page的定义。</para>
            <para>用对应的某个数字，Code Page Number，即Code Page中的标识符（Identifier），表示相应的字符编码。</para>
            <para>而一般Code Page也常缩写为<emphasis>CP</emphasis></para>
            <para>比如，CP936表示GBK中文编码，CP65001表示UTF-8编码，CP54936表示GB18030编码，CP950表示BIG5繁体中文等等。</para>

            <tip xml:id="tp.csharp_use_def_enc"><title>C#中使用当前系统默认编码处理字符</title>
                <para>对于C#来说，处理字符时涉及可能在不同环境中使用的话，那么最好用系统默认编码：</para>
                <programlisting>StreamReader reader = new StreamReader(path, System.Text.Encoding.Default);</programlisting>
            </tip>
        
            <sect3 xml:id="windows_codepage_type"><title>Windows中的Code Page分类：ANSI和OEM</title>
                <para>Windows中的Code Page，按照引用领域来划分，可以分为两类：ANSI Code Page和 OEM Code Page</para>
                
                <sect4 xml:id="windows_ansi_code_page"><title>Windows的ANSI Code Page表</title>
                    <para>ANSI Code Page的官网正式叫法其实是Windows Code Page。但是由于ANSI Code Page被误用的太广泛了，索性微软也就接受了此叫法，然后就叫做ANSI Code Page了。</para>
                    <para>类似地，ANSI Code Page=ANSI Windows Code Page</para>

                    <tip xml:id="tp.why_win_cp_called_ansi_cp"><title>Windows的Code Page为何被误称为ANSI Code Page</title>
                        <para>Windows的Code Page中用的最广泛的是Windows 1252，其用于英语和西欧语言字符。</para>
                        <para>Windows 1252是基于ANSI草案（ANSI draft）而设计的。</para>
                        <para>结果，本来叫做Windows Code Page，就被很多不熟悉的人误读为ANSI Code Page</para>
                        <para>而实际上，（作为标准制定者的）ANSI和ISO，都从来没有去标准化Windows的Code Page，即没有为Windows Code Page指定过任何标准。</para>
                        <para>但是呢，由于ANSI Code Page被误用的太普遍了，导致微软官方也都承认此叫法了。</para>
                        <para>总之，记住一点，<emphasis>ANSI Code Page，就是Windows Code Page</emphasis>，就行了。</para>
                    </tip>

                    <para>ANSI Code Page主要是用于Windows系统中，本地编码是非Unicode的，图形用户界面（GUI）程序。</para>
                    <para>ANSI的Code Page相关的表格，参见<xref linkend="ansi_codepage_tables" /></para>
                </sect4>
                
                <sect4 xml:id="windows_oem_code_page"><title>Windows的OEM Code Page表</title>
                    <para>OEM Code Page主要是用于Windows系统中的命令行界面（console）程序，虚拟DOS。</para>
                    <para>OEM Code Page可以视为是DOS和IBM PC时代的（过渡）剩余产品。</para>
                    <para>除了ANSI Code Page之外，之所以又设计出一个OEM Code Page，是因为：</para>
                    <orderedlist>
                        <listitem>兼容性
                            <para>因为作为新的图形用户界面系统的Windows，也要兼容旧的命令行程序，即向后兼容性。</para>
                        </listitem>
                        <listitem>字体和硬件的要求
                            <para>字体和旧的VGA硬件建议，文字图形界面所用的编码，最好和Code Page 437兼容。</para>
                            <para>多数的OEM的Code Page，和（非ASCII的）后半部分的CP437，都是公用同一套代码点(code point)的。</para>
                            <para>一般的OEM Code Page的后半段编码，和ANSI Code Page，完全不同。不过，对于部分双字节编码的，定长的Code Page（如泰语的847，越南语的1258）和多字节CJK编码的Code Page（如932,936,949,950）来说，ANSI和OEM的Code Page，都用的同一套编码。</para>
                        </listitem>
                    </orderedlist>

                    <para>和OEM Code Page相关的表格，参见<xref linkend="oem_codepage_tables"/></para>
                </sect4>
                
                <sect4 xml:id="windows_common_codepages"><title>一些常见的Code Page表</title>
                    <para>其中，ANSI和OEM共有的一些Code Page，可参见<xref linkend="ansi_oem_common_codepage_tables" /></para>
                    <para>而其他一些常见的Code Page，可参见<xref linkend="some_common_codepage_tables" /></para>
                </sect4>
            </sect3>
            
            <sect3 xml:id="all_code_pages"><title>所有的Code Page表</title>
                <para>除了ANSI和OEM，以及ANSI，OEM共有的Code Page之外，其他还有很多Code Page定义。</para>
                <para>关于<emphasis>所有的Windows中的Code Page的定义</emphasis>，可在微软官网<xref linkend="ref.code_page_identifiers" />中找到。</para>
                <para>此处已收录至<xref linkend="all_codepage_tables" />，以方便查阅。</para>
            </sect3>
        </sect2>
    </sect1>


    <sect1 xml:id="ansi_encoding"><title>ANSI字符编码</title>
        <sect2 xml:id="whatis_ansi"><title>ANSI是啥</title>
            <para>ANSI，本身是<emphasis>American National Standards Institute</emphasis>的缩写，中文翻译为<emphasis>美国国家标准学会</emphasis></para>
            <para>ANSI是个非营利组织，其负责制定美国国家标准。</para>
        </sect2>
        
        <sect2 xml:id="ansi_enc_rule"><title>ANSI编码规则</title>
            <para>ANSI字符编码的规则，或者是其所包含的字符的由来，主要是：</para>
            <orderedlist>
                <listitem>0-127   (0x00-0x7F)
                    <para>完全和7位编码的ASCII字符集(ASA X3.4-1963)相同</para>
                </listitem>
                <listitem>128-159 (0x80-0x9F)
                    <para>一些可打印字符</para>
                    <para>这部分的编码，与国际编码ISO 8859-1的做法不同，ISO 8859-1是将此部分编码用于控制字符</para>
                </listitem>
                <listitem>160-255 (0xA0-0FF)
                    <para>参考了ISO 8859-1中的字符</para>
                </listitem>
            </orderedlist>
            <para>由此可以看出，ANSI中很多字符，和ISO-8859中的字符，看起来非常相似。</para>
            <para>这就导致了很多人误以为，ANSI和ISO-8859是一回事呢。</para>
            <para>总结：</para>
            <inlineequation>
                <para>ANSI</para>
                <para>= Windows Code Page 1252</para>
                <para>= Windows Codepage 1252</para>
                <para>= Windows 1252</para>
                <para>= CP 1252</para>
                <para>= 共256个字符</para>
                <para>= 0-127的ASCII + 128-159的可打印字符 + 160-255的和ISO 8859-1中类似的字符</para>
            </inlineequation>
        </sect2>

        <sect2 xml:id="ansi_cp1252_enc_table"><title>ANSI (Windows 1252)编码表</title>
            <para>关于ANSI（Windows 1252）编码表格，可以参考：</para>
            <para><xref linkend="ref.ansi_charset_unicode_html" /></para>
            <para><xref linkend="ref.ms_windows_cp_1252_ansi" /></para>
        </sect2>

        <sect2 xml:id="whatis_ansi_encoding"><title>ANSI编码与ANSI的关系</title>
            <para>既然ANSI负责制定美国的国标，而在计算机方面，由于计算机最早是从美国最开始发展的，相应的所用到的字符编码方面，ANSI也制定了对应的标准，所以就叫做ANSI字符编码/ANSI字符集，英文为ANSI Code/ANSI Encoding/ANSI set/ANSI charset</para>
        </sect2>

        <sect2 xml:id="ansi_and_windows_1252"><title>ANSI字符编码和Windows 1252</title>
            <para>Windows为了支持英语和西欧字符，自己设计了一个编码，对应的在Code Page号是1252，被称为Windows 1252。</para>
            <para>Windows 1252的设计，是参考了ANSI草案(ANSI Draft)。</para>
            <para>而ANSI draft后来发展成为正式的国际标准：ISO 8859-1</para>
            <para>即，Windows 1252是在其成为正式标准ISO 8859-1之前而设计的，因此很容易理解，Windows 1252和ISO 8859-1不是完全等同的。</para>
            <para>下面就来简要说说两者的区别。</para>

            <sect3 xml:id="windows1252_vs_iso8859_1"><title>Windows 1252和ISO 8859-1之间的区别</title>
                <para>Windows 1252和ISO 8859-1基本等同</para>
                <para>有点不同的是，在128-159(0x80-0x9F)的范围的值，ISO 8859-1编码为控制字符，而微软编码为可打印字符。</para>

                <tip xml:id="tp.windows_1252_vs_ansi"><title>Windows 1252 vs. ANSI</title>
                    <orderedlist>
                        <listitem>类似<xref linkend="tp.why_win_cp_called_ansi_cp" />，Windows 1252也被误称为ANSI编码,所以此处也可以说是ANSI编码和ISO 8859-1之间的区别。</listitem>
                        <listitem>而由于ISO 8859-1对应的Latin-1的西欧语言，所以此处也可以称为ANSI编码和ISO Latin-1之间的区别，比如<xref linkend="ref.ascii_ansi_utf8" /></listitem>
                        <listitem>
                            <para>微软的此种变体，有各种叫法：ANSI/Windows-1252/Windows Latin-1</para>
                            <para>甚至有些微软的程序将其叫做Western European (Windows)。</para>
                            <para>更有甚至，由于不清楚，而错称其为ASCII</para>
                        </listitem>
                    </orderedlist>
                </tip>
                
                <note xml:id="nt.latin_1_notepad_messy"><title>包含Lattin-1的内容在Notepad中显示乱码</title>
                    <para>因此，如果你把包含了128-159范围内的ISO Latin-1编码的文件，用Windows的记事本Notepad去另存为为ANSI的话，则会导致文件内容被错误处理了。</para>
                    <para>因为本身的那些128-159的字符，是控制字符，但是却被Notepad识别为可打印的字符了。</para>
                </note>
            </sect3>

            <para>总之，对于Windows 1252，目前的各种叫法，可以理解为：</para>
            <para>ANSI = Windows 1252 = CP 1252 = Windows code page 1252 = Windows Latin-1</para>
        </sect2>
        
        <sect2 xml:id="why_ansi_called_native"><title>为何"ANSI编码"（在Windows中）被称为"本地编码"</title>
            <para>先说一下本地编码，所谓本地编码，即当前Windows中的二进制的值，用何种编码去解析，然后显示出对应的该编码中的字符。</para>
            <para>即，当然系统使用什么类型的编码。</para>
            <para>而ANSI编码，根据前面内容得知，只是一个普通的对应于Windows 1252的一个编码而已。并不是其他某些编码合集的总称。</para>
            <para>但是有时候，却又看到有人把ANSI编码解释为“本地编码”，比如<xref linkend="ref.char_byte_encoding" /></para>
            <para>其意思，就是<xref linkend="ref.code_pages" />中所说的，Windows code pages有时又被称为"active code pages"，"system active code pages"。</para>
            <para>而作为微软用A表示ANSI版本的函数，W表示Wide，Unicode版本的函数，此时所有的A版本的函数，就都用的是当前有效的Code Page,即"本地编码"了</para>
            <para>其中,Windows系统中，当前有且只有一个active Windows code page。</para>
            <para>也就意味着，此处所谓的ANSI编码，就相当于之前所说的Code Page了，即当前系统采用何种编码去解析字符</para>
            <para>也就是你当前系统中设置的本地编码为何种编码，然后系统中，遇到需要解析的字符，就按照你所设置的本地编码去解析了。</para>
            <para>比如，本身对于中文GBK编码的字符，如果你本地编码设置为UTF-8，那么按照UTF-8编码去解析出来的GBK字符，当前就是乱码了。</para>
            <para>而只有正确设置为GBK，才能正确解析原本就是GBK编码后的字符，才能正确显示出中文。</para>
            <para>同理，用GBK编码去解析原本用UTF-8编码后的字符，也会导致乱码。</para>
            <tip>
                <para>这种乱码问题，常常会在和编码打交道的事情中遇到</para>
                <para>比如Python中在命令行cmd中打印输出字符串，如果本身字符串是GBK编码的，那么你的cmd中的本地编码，就要设置为是936 (ANSI/OEM - Simplified Chinese GBK)，这样中文字符才能正确显示。</para>
                <para>当然，如果你本身输出的字符中，即包含UTF-8编码的字符，又包含GBK编码的字符，那么则是无论如何设置，都是无法同时正常显示的。除非你转换为Unicode编码，然后让Python输出函数自动处理，才可以正确显示。</para>
            </tip>
        </sect2>
    </sect1>
    
    <sect1 xml:id="bom"><title>BOM</title>
        <sect2 xml:id="whatis_bom"><title>BOM是什么</title>
            <para>BOM是一个Unicode字符。</para>
            <para>BOM用于指示文件/字符流的大小端（字节序）。</para>
            <para>不同编码所对应的BOM不同。</para>
        </sect2>

        <sect2 xml:id="why_bom"><title>为何需要BOM</title>
            <para>即使对于字符进行了某种编码，可以正确读取/写入，可以正常显示字符了。</para>
            <para>但是遇到将一个文件/字符流，从一个地方传输到另一个地方的话，就会遇到一些问题：</para>
            <para>比如，本地是一个用UTF-16 LE编码的文件，传入到网络的另一端，接受者怎么知道你用的是UTF-16 LE的编码，而不是UTF-16 BE呢？</para>
            <para>如果不知道，用了错误的UTF-16 BE去解码，且不是会导致乱码问题了。</para>
            <para>所以，就需要一个说明和解释，目前的做法就是，在文件头（字符流的开始），添加一个BOM，Byte Order Mark，字节序的标记，用于表示此编码是LE还是BE。</para>
        </sect2>
        
        <sect2 xml:id="bom_table"><title>BOM表</title>
            <para>相关的不同编码所用的BOM，参见摘录自<xref linkend="ref.wiki_byte_order_mark" />的<xref linkend="tbl.bom_table" /></para>
            <para>关于UTF-8的BOM: EF BB BF,可参考<xref linkend="utf8_bom_efbbbf" /></para>
        </sect2>

    </sect1>

    <sect1  xml:id="zhcn_charset_encoding"><title>中文字符编码标准</title>
        <sect2 xml:id="gb2312_gbk_gb18030"><title>GB2312，CP936，GBK，GB18030，GB13000</title>
            <sect3 xml:id="enc_gb2312"><title>GB2312</title>
                <para>1980年，中国制定了GB2312-80，一共收录了 7445 个字符，包括 6763 个汉字和 682 个其它符号。</para>
                <para>GB2312-80，简称为GB2312。</para>
                <para>在 Windows 中的代码页（Code Page）是 CP936。</para>
            </sect3>

            <sect3 xml:id="enc_gb13000"><title>GB13000</title>
                <para>1993年，国际标准Unicode 1.1版本推出，收录中国大陆、台湾、日本及韩国通用字符集的汉字，总共有20,902个。</para>
                <para>中国大陆订定了等同于Unicode 1.1版本的“GB 13000.1-93”，简称为GB13000。</para>
                <para> GB13000，显然包含的GB2312已有的文字和其他很多为包含的文字，如GB 2312-80推出以后才简化的汉字（如“啰”），部分人名用字（如中国前总理朱镕基的“镕”字），台湾及香港使用的繁体字，日语及朝鲜语汉字等。</para>
            </sect3>

            <sect3 xml:id="enc_gbk"><title>GBK</title>
                <para>微软，对GB2312-80的扩展，即利用GB 2312-80未使用的编码空间，收录所有的GB 13000.1-93和Unicode 1.1之中的汉字全部字符，制定了GBK编码。</para>
                <para>GBK 收录了 21886 个符号，它分为汉字区和图形符号区。汉字区包括 21003 个字符。</para>
                <para>GBK 作为对 GB2312 的扩展，在现在的 Windows 系统中仍然使用代码页 CP936 表示，但是同样的 936 的代码页跟一开始的 936 的代码页只支持 GB2312 编码不同，现在的 936 代码页支持 GBK 的编码，GBK 同时也向下兼容GB2312 编码。</para>
                <para>所以，技术编码上，GBK兼容旧的GB2312，但是编码方式和GB13000不同，不兼容GB13000，但是所包含文字上，算是和GB13000相同。</para>
            </sect3>
            
            <sect3 xml:id="enc_gb18030"><title>GB18030</title>
                <para>GBK自身并非国家标准，只是曾由国家技术监督局标准化司、电子工业部科技与质量监督司公布为“技术规范指导性文件”。</para>
                <para>原始GB13000一直未被业界采用，2000年，国家出了标准GB18030-2000，简称GB18030，技术上兼容GBK而非GB13000，取代了 GBK1.0，成了正式的国家标准。</para>
                <para>该标准收录了 27484 个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。</para>
                <para>现在的PC平台必须支持 GB18030 ，对嵌入式产品暂不作要求。所以手机、MP3 一般只支持 GB2312。</para>
                <para>GB18030 在 Windows 中的代码页是 CP54936。</para>
                <para>这么多汉字编码标准的关系，总结起来就是<xref linkend="zhcn_enc_relation"/>中所介绍的。</para>
            </sect3>
        </sect2>

        <sect2 xml:id="zhcn_enc_relation"><title>各种中文字符编码标准的关系</title>
            <para>（ 中国大陆的标准）<emphasis>GB 13000.1-93</emphasis></para>
            <para>=（国际标准）<emphasis>Unicode 1.1</emphasis></para>
            <para></para>
            <para>（中国大陆标准）<emphasis>GB2312-80</emphasis></para>
            <para>= 简称<emphasis>GB2312</emphasis></para>
            <para>= Windows系统中的<emphasis>原先的CP936</emphasis></para>
            <para></para>
            <para>（微软制定的）<emphasis>GBK</emphasis></para>
            <para>= （微软在编码方面）<emphasis>对 GB2312 的扩展</emphasis></para>
            <para>= （微软在所包含字符方面上包含了）<emphasis>GB 13000.1-93</emphasis> + 其他部分汉字+ 台湾和香港的繁体 + 日语 + 朝鲜汉字 </para>
            <para>=  <emphasis>Unicode 1.1</emphasis> + 其他部分汉字+ 台湾和香港的繁体 + 日语 + 朝鲜汉字</para>
            <para>对于<emphasis>GBK</emphasis>：</para>
            <itemizedlist>
                <listitem><emphasis>在编码方面：</emphasis>向下兼容GB2312，但是和GB 13000不同</listitem>
                <listitem><emphasis>在内容方面：</emphasis>等价于GB13000</listitem>
            </itemizedlist>
            <para></para>
            <para>微软中<emphasis>现在的新的CP936</emphasis></para>
            <para>= <emphasis>GBK</emphasis></para>
            <para>=兼容旧的GB2312</para>
            <para><emphasis></emphasis></para>
            <para>在技术编码方面上，演化顺序为：</para>
            <para><emphasis>ASCII &rArr; GB2312 &rArr; GBK &rArr; GB18030</emphasis></para>
            <para>后者对之前的，都是支持之前的编码，即向下兼容，即同一个字符，在这些编码中，都是同样的值，后面的标准，支持更多的字符。</para>
            <para>区分中文编码的方法是高字节的最高位不为 0。</para>
            <para>按照程序员的称呼，GB2312、GBK 到 GB18030 都属于<emphasis>双字节字符集 (DBCS)</emphasis></para>
            <table xml:id="tbl.zhcn_charsets"><title>中文字符相关编码标准</title>
                <tgroup cols="4">
                    <colspec colnum="1" colname="col1" colwidth="0.7*" />
                    <colspec colnum="2" colname="col2" colwidth="1.5*" />
                    <colspec colnum="3" colname="col3" colwidth="0.7*" />
                    <colspec colnum="4" colname="col4" colwidth="1.7*" />
                    
                    <thead align="center">
                        <row><entry>编码标准</entry><entry>别名</entry><entry>标准所属</entry><entry>包含字符</entry></row>
                    </thead>
                    <tbody>
                        <row><entry>ASCII</entry><entry></entry><entry>国际通用</entry><entry></entry></row>
                        <row><entry>GB2312</entry><entry>微软Windows中以前的CP936</entry><entry>中国大陆</entry><entry>6763 个汉字和 682 个其它符号</entry></row>
                        <row><entry>Unicode 1.1</entry><entry></entry><entry>国际通用</entry><entry>20,902个字符</entry></row>
                        <row><entry>GB13000</entry><entry></entry><entry>中国大陆</entry><entry>20,902个字符</entry></row>
                        <row><entry>GBK</entry><entry>微软Windows中现在的CP936</entry><entry>微软</entry><entry>21886 个符号</entry></row>
                        <row><entry>GB18030</entry><entry>微软Windows中的CP54936</entry><entry>中国大陆</entry><entry>27484 个汉字+其他少数民族字符</entry></row>
                    </tbody>
                </tgroup>
            </table>
        </sect2>
    </sect1>

    <sect1 xml:id="char_exchange_spec"><title>字符存储（交换）标准</title>
        <para>下表列出了常见的字符编码的标准，及其对应的交换存储时候所用的标准：</para>
        <table xml:id="tbl.char_exchange_spec"><title>字符（存储）交换标准</title>
            <tgroup cols="3">
                <colspec colnum="1" colname="col1" colwidth="1*" />
                <colspec colnum="2" colname="col2" colwidth="1*" />
                <colspec colnum="3" colname="col3" colwidth="1*" />
                
                <thead align="center">
                    <row><entry namest="col1" nameend="col2" >字符编码标准</entry><entry morerows="1" valign="middle">存储(交换/传输)标准</entry></row>
                    <row><entry>包含字符</entry><entry>字符编码领域的叫法</entry></row>
                </thead>
                
                <tbody>
                    <row><entry>英文</entry>
                        <entry>
                            <simplelist type="vert" columns="1">
                                <member>ASCII</member>
                                <member>==ISO/IEC 646</member>
                            </simplelist>
                        </entry><entry>ASCII</entry></row>
                    <row><entry>欧洲多国的字符</entry><entry>ISO 8859</entry><entry></entry></row>
                    <row><entry morerows="2" valign="middle">通用(的任何)字符</entry><entry morerows="2" valign="middle">Unicode</entry><entry>UTF<co id="co.utf" linkends="co.note.utf"/>-8</entry></row>
                    <row><entry colname="col3">UTF<coref linkend="co.utf"/>-16</entry></row>
                    <row><entry colname="col3">UTF<coref linkend="co.utf"/>-32</entry></row>
                    <row><entry morerows="2" valign="middle">简体中文<co id="co.zhcn" linkends="co.note.zhcn"/></entry>
                        <entry>
                            <simplelist type="vert" columns="1">
                                <member>GB2312</member>
                                <member>==GB2312-80</member>
                                <member>==GB</member>
                                <member>==GB0<co id="co.gb0" linkends="co.note.gb0"/></member>
                            </simplelist>
                        </entry><entry morerows="2" valign="middle">EUC<co id="co.euc" linkends="co.note.euc"/>-CN</entry></row>
                    <row><entry colname="col2">GBK</entry></row>
                    <row><entry colname="col2">GB18030</entry></row>
                    <row><entry morerows="2" valign="middle">繁体中文</entry>
                        <entry morerows="2" valign="middle">
                            <simplelist type="vert" columns="1">
                                <member>BIG5</member>
                                <member>==大五码</member>
                                <member>==五大码</member>
                            </simplelist>
                        </entry><entry>CCCII</entry></row>
                    <row><entry colname="col3">CNS-11643</entry></row>
                    <row><entry colname="col3">EUC<coref linkend="co.euc"/>-TW</entry></row>
                    <row><entry morerows="3" valign="middle">日文</entry>
                        <entry morerows="2" valign="middle">
                            <simplelist type="vert" columns="1">
                                <member>JIS X 0208</member>
                                <member>== JIS C 6226和JIS X 0212</member>
                            </simplelist>
                        </entry><entry>Shift JIS</entry></row>
                    <row><entry colname="col3">ISO-2022-JP</entry></row>
                    <row><entry colname="col3">EUC<coref linkend="co.euc"/>-JP</entry></row>
                    <row><entry colname="col2">JIS X 0213</entry><entry>EUC-JISX0213</entry></row>
                    <row><entry>韩文</entry>
                        <entry>
                            <simplelist type="vert" columns="1">
                                <member>KS X 1001</member>
                                <member>== KS C 5601</member>
                            </simplelist>
                        </entry><entry>EUC<coref linkend="co.euc"/>-KR</entry></row>
                </tbody>
            </tgroup>
        </table>
        <calloutlist>
            <callout id="co.note.utf" arearefs="co.utf">
                <para>UTF==Unicode Transformation Format==Unicode转换格式</para>
            </callout>
            <callout id="co.note.zhcn" arearefs="co.zhcn">
                <para>关于中文字符编码的各种标准的演化，可以参考<link xl:href="http://www.crifan.com/files/doc/docbook/zhcn_charset/release/html/zhcn_charset.html">中文字符编码标准+Unicode+Code Page</link></para>
            </callout>
            <callout id="co.note.gb0" arearefs="co.gb0">
                <para>关于GB0，另外还有其他的GBn，也是关于中文的国家标准：</para>
                <orderedlist>
                    <listitem>GB1==GB/T 12345 – 90==《信息交换用汉字编码字符集 第一辅助集》</listitem>
                    <listitem>GB2==GB/T 7589  – 87==《信息交换用汉字编码字符集 第二辅助集》</listitem>
                    <listitem>GB3==GB  13131  – 91==《信息交换用汉字编码字符集 第三辅助集》</listitem>
                    <listitem>GB4==GB/T 7590  – 87==《信息交换用汉字编码字符集 第四辅助集》</listitem>
                    <listitem>GB5==GB  13132  – 91==《信息交换用汉字编码字符集 第五辅助集》</listitem>
                </orderedlist>
                <para>关于GB的含义，即国标的首字母。其中，强制标准冠以“GB”，推荐标准冠以“GB/T”。</para>
            </callout>
            <callout id="co.note.euc" arearefs="co.euc">
                <para>EUC==Extended Unix Code</para>
            </callout>
        </calloutlist>
    </sect1>
    
    <sect1 xml:id="glyph_char_relation"><title>字形和你所看到的字符的关系</title>
        <para>对于某个字符，其字形是固定的，是对应的字符编码标准，即编码集中所定义好了的。比如，入门的“入”，这一撇一捺，是连在一起的，你不能写错了，写成左右分开的，那错写成了八个的“八”了。而这样的字符的形状，简称字形，是编码中定义好的，你不能随便乱写。</para>
        <para>但是同一个字符，具体的字体，大小等，则是按照自己喜好去设置的，是留给其他软件来处理的，比如宋体的“宋”这个汉字，不同的字体，会显示出来不同的效果：</para>
        <figure xml:id="fg.zhcn_song_effect"><title>汉字“宋”的不同字体</title>
            <mediaobject>
                <imageobject role="html"><imagedata fileref="images/zhcn_song_effect.png" scalefit="0" width="100%" /></imageobject>
                <imageobject role="fo">  <imagedata fileref="images/zhcn_song_effect.png" scalefit="1" width="100%" /></imageobject>
            </mediaobject>
        </figure>
        <para>这样的对于同一个字符的后期处理，即想要用什么样的字体，什么样的大小来显示等，都是后期软件，比如浏览器，微软的word等文本编辑器中去设置的。</para>
    </sect1>
</chapter>